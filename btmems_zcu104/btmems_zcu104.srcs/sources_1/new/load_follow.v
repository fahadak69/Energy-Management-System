`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: Syed Fahad Akhtar 
// 
// Create Date: 04/30/2021 12:35:18 PM
// Design Name: 
// Module Name: load_follow
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description:  Peak Shaving Module
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created

//Logic Description:
//This code performs peak shaving as well as export control
//When user control mode is 1, bess pid performs peak shaving. Additionally, if export priority is set to 0, it commands bess to absorb all power, when export 
//proiirty is 1, bess pid disables bess charging and only performs peak shaving. The export limit PID maintains utility export below a user defined threshold by
//curtailing PV  ------------- UPDATED NOTES POST TESTING --------- Keep export priority to 1, because when priority is 0 and BESS is supposed to charge to absorb
//excess power, the logic is faulty (it fluctuates between charging and zero all the time as POI oscillates between +ve and -ve, see "reference 1" which results
//in this behavior but is required for peak shaving). You should use a separate PID to absorb excess power when export priority is set to 0

//When user control mode is 3, bess pid continues to perform peak shaving as before. BESS pid disables bess charging in this mode (by fixing export priortiy to 1
//irresptive of actual export priority value from the user). Exrport limit PID in this mode is used to maintain utility export below user defined threshold by
//curtailiing BESS power. This BESS setpoint is added as an offset to BESS dispatch setpoint in C code generated by optimization algo. Note that in this mode, 
//when there is non-zero utility export, the BESS PID output stays at zero (the total output of this module is sum of BESS PID output and Export Limit PID output) 

// Additional Comments: 
// 1- For correct operation, reference values, feedback value, max and min limit must all be same unit (watts or kw or MW etc). Type of unit to be determined from 
// external device modbus mapping
// 2- PID IP I have generated is 32bit fixed point with 7bit for fraction part and 25bit (incl. sign bit) for integer part. Fraction bits are only to enable decimal 
// kp/ki/kd gains. All other values crossing CPU domain must be integers else CPU will intrepret them as floating point. 
// 3- kp/ki/kd values are entered by the user (via HMI or webpage etc) in the decimal (up to 2 decimal places). In software, multiply user entered kp/ki/kd values by 128 
// (which is the value closest to 100 in terms of power of 2) and change from float to int data type. This will truncate the decimal portion of the modified kp/ki/kd 
// values (loss of accuracy is minimal I have checked). Then shift left by 7 bits (so multiply again by 128) to convert to fixed point format used here. Note that inside
// the PID IP, I divide these gains by 128 to get original user entered value
// 4- For utility, import reading from the meter should be +ve
// 5- For BESS and PV, generator sign convention is used, so discharge is +ve
// 6- Logic assumes, when export priority is enabled, all the excess PV power can be exported. If only some of the excess can be exported, 
// battery should be charged, but logic doesnt do that currently
// 7- Integer to fixed point and vice versa conversion for CPU is handled here
// 8- One of the assumptions is that once input data form an asset becomes valid, it will stay latched until next valid. Also two consecutive valids (input or output) 
// will be separated by many cycles due to readback delay of external comm interface such as MODBUS
// 9 - the scaling of usr_bess_maxsoc, usr_bess_minsoc input and bess_soc_r must match be the same coming from CPU. Also this can be SoC or SoE, logic will be same
// 10 - Some of the assumptions can be relaxed if pv meter data is also available. Currently the logic only looks at POI meter for residential applications
// 11 - Philosophy here is that every time export exceeds the user defined limit, it curtails PV. When user control mode is 3, BESS is curtailed instead of PV
//Test Note 1: This was set to zero before. I think it must be non-zero else a -ve error value can get stuck as -ve even if error needs to be zero. Test this case
// 12 - This logic basically takes care of two edge cases. One is when error is present (-ve error in this case as +ve is capped to zero) and there is loss of comms 
//with PV for sometime. The valid keeps getting asserted until error goes back to zero (i.e. PV comms comes back and implement the setpoint). The second case is 
//that when error turns from -ve to +ve and PID output becomes zero meaning PV should be set back to max, the valid gets asserted so that command can be sent 
//(next time if error remains +ve valid wont be asserted since previous and current output will be same). However, as of now, there is no loss of comms protection
//on this seconds case. If controller looses comms with asset and PV setpoint is being set from curtailment back to full user PV max value, the setpoint wont be 
//received and controller wont know that it was not received and hence PV will remain stuck at zero. Fix this bug in future
// 13- assert BESS P valid only if:
//      * Error is less than zero (so as long as err is zero, we need to keep sending setpoint, this also accounts for comms loss case)
//      * Export priority is zero and POI meter is showing export (in this as well, we need to make error zero to shift all export to bess charging)
//      * Error is greater than zero and previous output is not same as new output (this is only when expo prio is 1 so we dont want to send setpoint except when error
//                                                                                  goes from -ve to +ve for first time, so that we reduce bess discharge back to zero) 
// 14 - I believe this is already covered by second condition of pv_pvld_w logic, bring code back in if you see any issues during initilization
// 15 - InitN reset the integral and derivative sum back to zero value. This logic is needed as otherwise when error is positive (meter POI is less than user limit), 
//      the summation keeeps increasing (setting Ki to zero doesnt reset previous accumulated sum, it only zeroes out (Ki * e) term) and reaches integral max limit. 
//       when error goes back to -ve (POI greater then user import limit) and we need to discharge BESS, depending upon value of Kp and Ki (which incase of STCH MG
//       is very smalll due to site characteristics (0.1 and 0.04 resp.)), it can take very long time (up to few minutes) for the +ve accumulated sum to decrease (as 
//       -ve error tries to descrease the sum) before it can go back -ve and allow BESS to discharge
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

`include "defines.vh"

module load_follow (
    input                   clkin,
    input                   arst_n,
    
    //POI Meter Interface
    input  signed   [31:0]  meter_poi_3p,       //sign convention: -ve for export to utility
    input                   meter_rdata_vld,

    //BESS INTERFACE
    input                       [31:0]  bess_soc_r,         //Note 9
    input       signed          [31:0]  bess_maxdschgpwr_r, //sign convention: +ve
    input       signed          [31:0]  bess_maxchgpwr_r,   //sign convention: +ve
    input                               bess_rdata_vld,
    output  reg signed          [31:0]  bess_p_w,           //sign convention: -ve for charge command
    output  reg                         bess_pvld_w,                             
    
    //PV INTERFACE
    input                           pv_rdata_vld,
    input                   [31:0]  pv_status_r,
    input                   [31:0]  pv_fault_r,
    input   signed          [31:0]  pv_wattsp_r,
    input   signed          [31:0]  pv_watt_r,
    output  reg signed      [31:0]  pv_p_w,                 //to asset dispatch module
    output  reg                     pv_pvld_w,              //to asset dispatch module

    //User Parameter Interface
    input  signed   [31:0]  usr_imp_lmt,        //sign convention: +ve values. (e.g value 0Watts). Must be integer only (if not integer, these values coming from cpu will be in floating point format)
    input  signed   [31:0]  usr_exp_lmt,        //sign convention: +ve values. (e.g value 5000Watts). Must be integer only 
    input  signed   [31:0]  usr_besschrg_lmt,   //sign convention: +ve values. (e.g value 5000Watts). Must be integer only 
    input  signed   [31:0]  usr_bessdsch_lmt,   //sign convention: +ve values. (e.g value 5000Watts). Must be integer only
    input  signed   [31:0]  usr_bess_kp,        //sign convention: +ve values. 
    input  signed   [31:0]  usr_bess_ki,        //sign convention: +ve values.
    input  signed   [31:0]  usr_bess_kd,        //sign convention: +ve values.
    input  signed   [31:0]  usr_pv_kp,          //sign convention: +ve values.
    input  signed   [31:0]  usr_pv_ki,          //sign convention: +ve values.
    input  signed   [31:0]  usr_pv_kd,          //sign convention: +ve values.
    input  signed   [31:0]  usr_bess_maxsoc,    //sign convention: +ve values. (e.g value 100). Must be integer only. Note 9
    input  signed   [31:0]  usr_bess_minsoc,    //sign convention: +ve values. (e.g value 2). Must be integer only. Note 9
    input  signed   [31:0]  usr_pv_max,         //sign convention: +ve values. (e.g value 5000Watts). Must be integer only
    input                   usr_exp_prio,       //(e.g value 0(no export))
    input                   usr_bess_en,
    input                   usr_pv_en,
    input           [7:0]  usr_ctrl_mode,
    input                   usr_param_vld      
    
    );

    // localparam  
    //     TMP_USR_IMP_LMT = 32'sd0,                   
    //     TMP_USR_EXP_LMT = 32'sd5000,                //sign convention: +ve values.  Temporary local para, repalce it with user input

    //     //In Watts. Must integer only (if not integer, these values coming from cpu will be in floating point format not fixed point)
    //     TMP_USR_BESSCHRG_LMT = 32'd5000,                 //Temporary local para, repalce it with user input
    //     //In Watts. Must be integer only (if not integer, these values coming from cpu will be in floating point format not fixed point)
    //     TMP_USR_BESSDSCH_LMT = 32'd5000,                 //Temporary local para, repalce it with user input

    //     //binary for 35.37*128 using 7bit for fraction and 25bit (incl. sign bit) for integer
    //     TMP_USR_KP       = 32'b010001101011110101110,  //Temporary local para, replace it with user input 
    //     //binary for 0.51*128
    //     TMP_USR_KI       = 32'b010000010100011,        //Temporary local para, replace it with user input
    //     //binary for 6.03*128
    //     TMP_USR_KD       = 32'b011000000111101011,     //Temporary local para, replace it with user input

    //     //binary for 35.37*128 using 7bit for fraction and 25bit (incl. sign bit) for integer
    //     TMP_USR_KP_PV       = 32'b010001101011110101110,  //Temporary local para, replace it with user input 
    //     //binary for 0.51*128
    //     TMP_USR_KI_PV       = 32'b010000010100011,        //Temporary local para, replace it with user input
    //     //binary for 6.03*128
    //     TMP_USR_KD_PV       = 32'b011000000111101011,     //Temporary local para, replace it with user input

    //     //export priority 
    //     TMP_USR_EXPRIO   = 1'b0,                        //Temporary local para, replace it with user input   

    //     //Max BESS SoC (the scaling of this input and bess_soc_r must match be the same coming from CPU)
    //     TMP_USR_MAXSOC   = 32'd100,                        //Temporary local para, replace it with user input  

    //     //Min BESS SoC (the scaling of this input and bess_soc_r must match be the same coming from CPU)
    //     TMP_USR_MINSOC   = 32'd2,                        //Temporary local para, replace it with user input  

    //     //MAX PV Power in Watts
    //     TMP_USR_PVMAX   = 32'sd5000;                        //Temporary local para, replace it with user input 

/*(* dont_touch = "true" *)*/ wire ap_ready;
wire explmt_ap_ready;
wire explmt_ap_done;
wire bess_ap_done;
wire signed [31:0] dout_0_V;
wire signed [31:0] dout_err_BESS;
wire signed [31:0] dout_0_Vtmp;
wire signed [31:0] lf_chrg_lmt_fxp;
wire signed [31:0] lf_dschrg_lmt_fxp; 
wire signed [31:0] lf_chrg_lmtfxp_err;
wire signed [31:0] lf_dschrg_lmtfxp_err; 
wire signed [31:0] usr_implmt_fxp; 
wire signed [31:0] meter_poi3p_fxp;
wire signed [31:0] usr_pvmax_fxp;
wire signed [31:0] usr_explmt;
wire signed [31:0] usr_explmt_fxp;
wire signed [31:0] meter_poi3ppv_fxp;
wire signed [31:0] dout0_explmtPID_err;
wire signed [31:0] dout0_explmtPID_errtmp;
wire signed [31:0] usr_pvmaxerr_fxp;
wire signed [31:0] dout1_explmtPID_err;
wire signed [31:0] lf_dschrg_lmt_fxperr;

reg pid_en;
reg meter_rdatavld_reg;
reg explmt_pid_en;
reg explmt_pid_rst;
reg explmt_ap_done_reg;
reg bess_ap_done_reg;

reg signed [31:0]  usr_implmt;
reg signed [31:0]  lf_chrg_lmt;
reg signed [31:0]  lf_chrg_lmterr;
reg signed [31:0]  dout_0_V1;
reg signed [31:0]  lf_dschrg_lmt;
reg signed [31:0]  lf_dschrg_lmt2;
reg signed [31:0]  lf_dschrg_lmterr;
reg signed [31:0]  lf_dschrg_lmt2err;
reg signed [31:0]  usr_pvmax;
reg signed [31:0]  meter_poi3p_pv;
reg signed [31:0]  pv_p_werr;
reg signed [31:0]  dout1_explmtPID_err_reg;
reg signed [31:0]  dout_0_bess;
reg signed [31:0]  dout_0_bess_prv;
reg signed [31:0]  usr_bess_ki_reg;
reg signed [31:0]  usr_pv_ki_reg;
reg                pid_rst;
reg                usr_pv_ki_reg_init;
reg                usr_bess_ki_reg_init;
reg signed [31:0]  pv_p_w_prv;
reg signed [31:0]  dout_err_BESS_reg;
reg                pv_p_trg;
reg signed [31:0]  meter_rdata_hld;
reg        [7:0]   usr_ctrlmd_reg ;
reg signed [31:0]  explmt_pid_min;
reg signed [31:0]  bess_p_werr;
reg                bessexplmt_pvld_w;
reg signed [31:0]  bessexplmt_p_w;
reg signed [31:0]  bessexplmt_p_w_prv;
reg signed [31:0]  besspkshv_p_w;
reg                besspkshv_pvld_w;
reg signed [31:0]  bessexplmt_p_w_reg;
reg signed [31:0]  besspkshv_p_w_reg;
reg                besspkshv_pvld_w_reg;
reg                bessexplmt_pvld_w_reg;
reg signed [31:0]  explmt_pid_max;
reg                InitN;
reg                InitN_pv;


assign lf_chrg_lmt_fxp = {lf_chrg_lmt[24:0],7'd0};

assign lf_dschrg_lmt_fxp = {lf_dschrg_lmt2[24:0],7'd0};

assign lf_chrg_lmtfxp_err = {lf_chrg_lmterr[24:0],7'd0};

assign lf_dschrg_lmt_fxperr = {lf_dschrg_lmterr[24:0],7'd0};

assign lf_dschrg_lmtfxp_err = {lf_dschrg_lmt2err[24:0],7'd0}; 

assign usr_implmt_fxp = {usr_implmt[24:0],7'd0};

assign meter_poi3p_fxp = {meter_poi_3p[24:0],7'd0};

assign usr_explmt = usr_exp_lmt;
assign usr_explmt_fxp = {usr_explmt[24:0],7'd0};

assign usr_pvmax_fxp = {usr_pvmax[24:0],7'd0};

assign meter_poi3ppv_fxp = {meter_poi3p_pv[24:0],7'd0};

assign usr_pvmaxerr_fxp = {usr_pv_max[24:0],7'd0};

always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        meter_rdatavld_reg   <= #`adly 1'b0;
    else
        meter_rdatavld_reg   <= #`adly meter_rdata_vld;
end


always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        usr_ctrlmd_reg   <= #`adly 1'b0;
    else
        usr_ctrlmd_reg   <= #`adly usr_ctrl_mode;
end


always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        meter_rdata_hld   <= #`adly 32'sd0;
    else if (meter_rdata_vld)
        meter_rdata_hld   <= #`adly meter_poi_3p;
end

always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
    begin
        pid_en   <= #`adly 1'b0;
    end
    else if (ap_ready  || (~((usr_ctrl_mode==8'd1) || (usr_ctrl_mode==8'd3))) || ~usr_bess_en)
    begin
        pid_en   <= #`adly 1'b0;    //deasserting to pause PID until next feedback data valid arrives or if user control mode is not peak shaving
                                    //pid_en can also be made a 1shot signal, sysgen simulation confirms correct operation with 1shot. Test it in an actual setup to be sure
    end
    else if (meter_rdata_vld)
    begin
        pid_en   <= #`adly meter_rdata_vld; 
    end   
end  


always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
    begin
        pid_rst   <= #`adly 1'b0;
    end
    else 
    begin
        pid_rst   <= #`adly usr_bess_en && ((usr_ctrl_mode==8'd1) || (usr_ctrl_mode==8'd3)); 
    end 
end 


//Charge limit for Peak Shaving PID Output 
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_chrg_lmt <= #`adly 32'd0;
    else if (bess_soc_r >= usr_bess_maxsoc) 
        lf_chrg_lmt <= #`adly 32'd0;
    else if ((usr_exp_prio) || (usr_ctrl_mode==3))//in mode 3, we curtail BESS output, if required, using the other PID
         lf_chrg_lmt <= #`adly 32'd0; //dont charge BESS, export excess solar. See note 6
    else if ((usr_imp_lmt>32'sd0) & (meter_poi_3p>32'sd0) & (meter_poi_3p<usr_imp_lmt)) // reference 1
         lf_chrg_lmt <= #`adly 32'd0; //this logic is to handle the case for example: target grid import = 3kW, actual grid import = 2kW, since actual is less than target, bess doesnt need to do anything. Without this logic, PID will try to charge bess to force 3kW of net import  
    else if (usr_besschrg_lmt < bess_maxchgpwr_r)
        lf_chrg_lmt <= #`adly usr_besschrg_lmt;
    else
        lf_chrg_lmt <= #`adly bess_maxchgpwr_r;

end

//PID Reference selection 
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        usr_implmt <= #`adly 32'sd0;
    else if (meter_poi_3p<32'sd0)
         usr_implmt <= #`adly 32'sd0;
    else
        usr_implmt <= #`adly usr_imp_lmt;
end


//Charge limit for Peak Shaving PID Error and Integrator
//Note originally xilinx PID code had same limit for PID error, integrator stage and output. I had to separate them to handle the case where say PID ref inupt is cahnged from zero to 3000 and feedback is 2000 and 
//export prio is zero, in this case battery shouldnt be set to charging mode to force 3000 output (else you would start charging from grid). In this case, if limits are not separated and if PID output previously was 
//-ve (i.e. BESS was discharging), the error will become zero in next cycle (becuase ref was changed from 0 to 3000), which will cause PID output to freeze at -ve value (since error is zero) and  hence the upper 
//limit of zero wont be applied and battery will keep discahrging instead of being at zero
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_chrg_lmterr <= #`adly 32'd0;  
    else if (usr_besschrg_lmt < bess_maxchgpwr_r)
        lf_chrg_lmterr <= #`adly usr_besschrg_lmt;
    else
        lf_chrg_lmterr <= #`adly bess_maxchgpwr_r;

end

//Discharge limit for Peak Shaving PID Output
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_dschrg_lmt <= #`adly 32'd0;
    else if (bess_soc_r <= usr_bess_minsoc)
        lf_dschrg_lmt <= #`adly 32'd0;
    else if (usr_bessdsch_lmt < bess_maxdschgpwr_r)
        lf_dschrg_lmt <= #`adly usr_bessdsch_lmt; 
    else 
        lf_dschrg_lmt <= #`adly bess_maxdschgpwr_r;
end

//Changing to 2's complement (discahrge limit to PID needs to be -ve)
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_dschrg_lmt2 <= #`adly 32'sd0;
    else 
        lf_dschrg_lmt2 <= #`adly (~lf_dschrg_lmt) + 32'sd1; //lf_dschrg_lmt * (-32'sd1);
end


//Discharge limit for Peak Shaving PID Error and Integrator
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_dschrg_lmterr <= #`adly 32'd0;
    else if (usr_bessdsch_lmt < bess_maxdschgpwr_r)
        lf_dschrg_lmterr <= #`adly usr_bessdsch_lmt; 
    else 
        lf_dschrg_lmterr <= #`adly bess_maxdschgpwr_r;
end

//Changing to 2's complement (discahrge limit to PID needs to be -ve)
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        lf_dschrg_lmt2err <= #`adly 32'sd0;
    else 
        lf_dschrg_lmt2err <= #`adly (~lf_dschrg_lmterr) + 32'sd1;
end

//*********************************
//- flipping PID output sign per bess generator sign convention (i.e. +ve cmd is discharge)
//- Truncating decimal part (accuracy loss is neglibigble since command is in Watts (not kw))
//- Changing from fixed point represenation back to normal integer represenation (for CPU)

//truncating fixed point to integer
assign dout_0_Vtmp[24:0] = dout_0_V[31:7]; 
genvar j;
generate
    for (j = 25; j < 32; j = j + 1) begin: genj
        assign dout_0_Vtmp[j] = dout_0_V[31]; //padding remaining bits with sign bit
    end
endgenerate

//inverting bits as part of 2's complement process
genvar i;
generate
    for (i = 0; i < 32; i = i + 1) begin: geni
        always @(*) begin
             dout_0_V1[i]   <= ~dout_0_Vtmp[i]; 
        end
    end
endgenerate

//adding 1 as part of 2's complement
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        dout_0_bess <= #`adly 32'sd0;
    else if (dout_0_V[31:7]==25'sd0) //if integer part is zero from PID, keep it zero  (if integer part is all 1, such as for -0.3, all 1s will be inverted to zero anyway)
        dout_0_bess <= #`adly 32'sd0;        
    else if ((dout_0_V[6:0]==7'sd0) || (dout_0_V[31]==1'sb0))
        dout_0_bess <= #`adly dout_0_V1 + 32'sd1;  //adding 1 to flip PID output sign (in  2's complement representation) 
    else
        dout_0_bess <= #`adly dout_0_V1;  //if decimal part is non-zero and interger part is -ve, integer part from PID is in 1's complement 
                                       //(not sure why but I confirmed from Sysgen). So a -ve number will be sign flipped to +ve just by inverting the bits
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        besspkshv_p_w <= #`adly 32'sd0;
    else
        besspkshv_p_w <= #`adly dout_0_bess;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        dout_0_bess_prv <= #`adly 32'sd0;
    else if(besspkshv_pvld_w)
        dout_0_bess_prv <= #`adly besspkshv_p_w;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        dout_err_BESS_reg <= #`adly 32'sd0;
    else
        dout_err_BESS_reg <= #`adly dout_err_BESS; 
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bess_ap_done_reg <= #`adly 1'b0;
    else
        bess_ap_done_reg <= #`adly bess_ap_done;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        besspkshv_pvld_w <= #`adly 1'b0;
    else 
        besspkshv_pvld_w <= #`adly ((dout_err_BESS_reg<32'sd0) || ((dout_err_BESS_reg>32'sd0)&&(dout_0_bess!=dout_0_bess_prv)) || ((~usr_exp_prio)&&(meter_rdata_hld<32'sd0))) & bess_ap_done_reg; //note 13
end



/*always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
    begin
        usr_bess_ki_reg       <= #`adly 32'sd0;
        usr_bess_ki_reg_init  <= #`adly 1'b0;
    end
    else if (~usr_bess_ki_reg_init)
    begin
        usr_bess_ki_reg       <= #`adly usr_bess_ki;
        usr_bess_ki_reg_init  <= #`adly 1'b1;
    end    
    else if (bess_ap_done)
        usr_bess_ki_reg <= #`adly ((dout_0_V==lf_chrg_lmt_fxp) || (dout_0_V==lf_dschrg_lmt_fxp)) ? 32'sd0 : usr_bess_ki; //disabling Integral whenn output saturates (an alternative way to implement anti-windup)
end*/

//Integral and Derivatve summ reset
always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
    begin
        InitN   <= #`adly 1'b0;
    end
    else 
    begin
        InitN   <= #`adly (dout_0_V==32'sd0) ? 1'b0 : 1'b1; //Note 15 
    end 
end 

//***********************************
    PID_Fxd7bFr PID_Fxd7bFr_instBESS (
        .ap_start   (pid_en),                         
        .ap_done    (bess_ap_done),
        .ap_idle    (),
        .ap_ready   (ap_ready),
        .ap_clk     (clkin),
        .ap_rst     (~pid_rst),
        .ap_ce      (1'b1),
        .InitN      (InitN),
        .coeff_0_V  (usr_bess_ki),           //Ki
        .coeff_1_V  (usr_bess_kd),               //Kd
        .coeff_2_V  (32'd0),                    //Constant (initial value)
        .coeff_3_V  (usr_bess_kp),               //Kp
        .coeff_4_V  (lf_chrg_lmt_fxp),          //max limit (charge signal)
        .coeff_5_V  (lf_dschrg_lmt_fxp),        //min limit (discharge signal) 
        .coeff_6_V  (lf_chrg_lmtfxp_err),       //max limit for error and integrator
        .coeff_7_V  (lf_dschrg_lmtfxp_err),     //min limit for error and integrator  
        .din_0_V    (usr_implmt_fxp),           //reference  
        .din_1_V    (meter_poi3p_fxp),          //feedback
        .dout_0_V   (dout_0_V),                 //control signal output
        .dout_1_V   (dout_err_BESS)             //error signal output 

    ); 


//********************************************
//PV Setpoint

//Changing to -ve value for PID
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        usr_pvmax <= #`adly 32'sd0;
    else 
        usr_pvmax <= #`adly (~usr_pv_max) + 32'sd1;//usr_pv_max * (-32'sd1);
end

//Flipping sign (grid export needs to be +ve value going into the PID)  
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        meter_poi3p_pv <= #`adly 32'sd0;
    else 
        meter_poi3p_pv <= #`adly (~meter_poi_3p) + 32'sd1;//meter_poi_3p * (-32'sd1);
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        explmt_pid_rst <= #`adly 1'b0; //active low reset
    else if (((usr_ctrlmd_reg!=3) && (usr_ctrl_mode==3)) || ((usr_ctrlmd_reg==3) && (usr_ctrl_mode!=3))) //create one-shot rst to reset PID whenever we enter/exit control mode 3
        explmt_pid_rst <= #`adly 1'b0;
    else if (usr_ctrlmd_reg==2)
        explmt_pid_rst <= #`adly 1'b0; //keep PID disabled when in load following
    else
        explmt_pid_rst <= #`adly 1'b1; //PID always enabled to supervise export limit, see note 11
end

always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        explmt_pid_en   <= #`adly 1'b0;
    else if (explmt_ap_ready || (~usr_pv_en && (usr_ctrl_mode!=3)) || (~usr_bess_en && (usr_ctrl_mode==3))) 
        explmt_pid_en   <= #`adly 1'b0;    
    else if (meter_rdatavld_reg)
        explmt_pid_en   <= #`adly meter_rdatavld_reg;   
end

/*always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
    begin
        usr_pv_ki_reg       <= #`adly 32'sd0;
        usr_pv_ki_reg_init  <= #`adly 1'b0;
    end
    else if (~usr_pv_ki_reg_init)
    begin
        usr_pv_ki_reg       <= #`adly usr_pv_ki;
        usr_pv_ki_reg_init  <= #`adly 1'b1;
    end    
    else if (explmt_ap_done)
        usr_pv_ki_reg <= #`adly ((dout0_explmtPID_err==32'd0) || (dout0_explmtPID_err==explmt_pid_min)) ? 32'sd0 : usr_pv_ki; //disabling Integral whenn output saturates (an alternative way to implement anti-windup)
end*/

//Integral and Derivatve summ reset
always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
    begin
        InitN_pv   <= #`adly 1'b0;
    end
    else 
    begin
        InitN_pv   <= #`adly (dout0_explmtPID_err==32'sd0) ? 1'b0 : 1'b1; //reset the sum when data output is zero (way to implement anti-windup)
    end 
end 

//******PID Parameter MUX, PV or BESS************
always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        explmt_pid_min <= #`adly 32'sd0; 
    else if (usr_ctrl_mode==3) 
        explmt_pid_min <= #`adly lf_dschrg_lmt_fxp;    
    else
        explmt_pid_min <= #`adly usr_pvmax_fxp;   
end

//explmt_pid_max is basically 2's complement of explmt_pid_min
always @ (posedge clkin or negedge arst_n)
begin
    if (~arst_n)
        explmt_pid_max <= #`adly 32'sd0; 
    else if (usr_ctrl_mode==3) 
        explmt_pid_max <= #`adly lf_dschrg_lmt_fxperr;    
    else
        explmt_pid_max <= #`adly usr_pvmaxerr_fxp;   
end
//***********************************************

    PID_Fxd7bFr PID_Fxd7bFr_instExpLmt (
        .ap_start   (explmt_pid_en),                         
        .ap_done    (explmt_ap_done),
        .ap_idle    (),
        .ap_ready   (explmt_ap_ready),
        .ap_clk     (clkin),
        .ap_rst     (~explmt_pid_rst),
        .ap_ce      (1'b1),
        .InitN      (InitN_pv),
        .coeff_0_V  (usr_pv_ki),        //Ki
        .coeff_1_V  (usr_pv_kd),            //Kd
        .coeff_2_V  (32'd0),                //Constant (initial value)
        .coeff_3_V  (usr_pv_kp),            //Kp
        .coeff_4_V  (32'd0),                //max limit for output
        .coeff_5_V  (explmt_pid_min),       //min limit for output (pv rating)
        .coeff_6_V  (explmt_pid_max),       //max limit for error and integrator - Test Note 1
        .coeff_7_V  (explmt_pid_min),       //min limit for error and integrator
        .din_0_V    (usr_explmt_fxp),       //reference  
        .din_1_V    (meter_poi3ppv_fxp),    //feedback
        .dout_0_V   (dout0_explmtPID_err),  //control signal output
        .dout_1_V   (dout1_explmtPID_err)   //error signal output 

    ); 

//- Truncating decimal part (accuracy loss is neglibigble since command is in Watts (not kw))
//- Changing from fixed point represenation back to normal integer represenation (for CPU)
assign dout0_explmtPID_errtmp[24:0] = dout0_explmtPID_err[31:7]; 
genvar k;
generate
    for (k = 25; k < 32; k = k + 1) begin: genk
        assign dout0_explmtPID_errtmp[k] = dout0_explmtPID_err[31]; //padding remaining bits with sign bit
    end
endgenerate    

//*********** Generating PV curtailment setpoint for load following and peak shaving mode***************************************************************************

//changing to 2's complement representation where required (if decimal part is non-zero and interger part is -ve, integer part from PID is in 1's complement)
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        pv_p_werr <= #`adly 32'sd0;
    else if (usr_ctrl_mode==3)
        pv_p_werr <= #`adly 32'sd0;//we curtail BESS in mode 3 not PV
    else if ((dout0_explmtPID_err[6:0]!=7'sd0) && (dout0_explmtPID_err[31]==1'sb1))
        pv_p_werr <= #`adly dout0_explmtPID_errtmp + 32'sd1;  //adding to convert to 2's complement representation 
    else
        pv_p_werr <= #`adly dout0_explmtPID_errtmp;
end

//Curtailing PV setpoint to limit grid export to the limit
//If grid export for a site will always be greater or equal to max PV output possible, pv_p_werr term can be removed 
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        pv_p_w <= #`adly 32'sd0;
    else
        pv_p_w <= #`adly usr_pv_max + pv_p_werr; //note that pv_p_werr will either be zero or -ve, never +ve non-zero
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        explmt_ap_done_reg <= #`adly 1'b0;
    else
        explmt_ap_done_reg <= #`adly explmt_ap_done; 
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        dout1_explmtPID_err_reg <= #`adly 32'sd0;
    else
        dout1_explmtPID_err_reg <= #`adly dout1_explmtPID_err; 
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        pv_p_w_prv <= #`adly 32'sd0;
    else if(pv_pvld_w)
        pv_p_w_prv <= #`adly pv_p_w;
    else
        pv_p_w_prv <= #`adly pv_p_w_prv;
end

/*//used to send initial setpoint to PV after design reset - see Note 14
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        pv_p_trg <= #`adly 1'b0;
    else if(explmt_ap_done_reg)
        pv_p_trg <= #`adly 1'b1;
    else
        pv_p_trg <= #`adly pv_p_trg;
end*/

//if logic causes timing bottleneck, just add a cycle delay to be able to pre-compute the sum (usr_pv_max + pv_p_werr)
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        pv_pvld_w <= #`adly 1'b0;
    else
        pv_pvld_w <= #`adly ((dout1_explmtPID_err_reg<32'sd0) || (((usr_pv_max + pv_p_werr)!=pv_p_w_prv) && (dout1_explmtPID_err_reg>32'sd0)) /*|| (~pv_p_trg)*/) & explmt_ap_done_reg; //see note 12
end

//***********************************************************************************************************************************************************************


//******Generating BESS discharge curtailment setpoint for BESS Dispatch optimization mode*******************************************************************************

//changing to 2's complement representation where required (if decimal part is non-zero and interger part is -ve, integer part from PID is in 1's complement)
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bess_p_werr <= #`adly 32'sd0;
    else if (usr_ctrl_mode!=3)  
        bess_p_werr <= #`adly 32'sd0;//we do BESS curtailment only in mode 3
    else if ((dout0_explmtPID_err[6:0]!=7'sd0) && (dout0_explmtPID_err[31]==1'sb1))
        bess_p_werr <= #`adly dout0_explmtPID_errtmp + 32'sd1;  //adding to convert to 2's complement representation 
    else
        bess_p_werr <= #`adly dout0_explmtPID_errtmp;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bessexplmt_p_w <= #`adly 32'sd0;
    else
        bessexplmt_p_w <= #`adly bess_p_werr;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bessexplmt_p_w_prv <= #`adly 32'sd0;
    else if(bessexplmt_pvld_w)
        bessexplmt_p_w_prv <= #`adly bessexplmt_p_w;
    else
        bessexplmt_p_w_prv <= #`adly bessexplmt_p_w_prv;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bessexplmt_pvld_w <= #`adly 1'b0;
    else
        bessexplmt_pvld_w <= #`adly ((dout1_explmtPID_err_reg<32'sd0) || ((bess_p_werr!=bessexplmt_p_w_prv) && (dout1_explmtPID_err_reg>32'sd0))) & explmt_ap_done_reg;
end

//*******************************************************************************************************************************************************

//**************************Generating combined BESS P output from Peakshaving and Export Limit PIDs**********************************
always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bessexplmt_p_w_reg <= #`adly 32'sd0;
    else if(bessexplmt_pvld_w)
        bessexplmt_p_w_reg <= #`adly bessexplmt_p_w;
    else
        bessexplmt_p_w_reg <= #`adly bessexplmt_p_w_reg;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        besspkshv_p_w_reg <= #`adly 32'sd0;
    else if(besspkshv_pvld_w)
        besspkshv_p_w_reg <= #`adly besspkshv_p_w;
    else
        besspkshv_p_w_reg <= #`adly besspkshv_p_w_reg;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
    begin
        besspkshv_pvld_w_reg  <= #`adly 1'b0;
        bessexplmt_pvld_w_reg <= #`adly 1'b0;
    end
    else
    begin
        besspkshv_pvld_w_reg  <= #`adly besspkshv_pvld_w;
        bessexplmt_pvld_w_reg <= #`adly bessexplmt_pvld_w;
    end
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bess_p_w <= #`adly 32'sd0;
    else
        bess_p_w <= #`adly bessexplmt_p_w_reg + besspkshv_p_w_reg;
end

always @(posedge clkin or negedge arst_n) begin
    if (~arst_n)
        bess_pvld_w <= #`adly 1'b0;
    else
        bess_pvld_w <= #`adly besspkshv_pvld_w_reg || bessexplmt_pvld_w_reg;
end


//**********************************************************************************************************************************

endmodule
